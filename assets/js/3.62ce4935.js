(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{257:function(t,e,a){t.exports=a.p+"assets/img/git-workflows-gitflow.e6ad004e.png"},258:function(t,e,a){t.exports=a.p+"assets/img/git-workflow-release-cycle-1historical.89113dc5.png"},259:function(t,e,a){t.exports=a.p+"assets/img/git-workflow-release-cycle-2feature.2a5d5c1d.png"},260:function(t,e,a){t.exports=a.p+"assets/img/git-workflow-release-cycle-3release.34908921.png"},261:function(t,e,a){t.exports=a.p+"assets/img/git-workflow-release-cycle-4maintenance.d606ac0e.png"},274:function(t,e,a){"use strict";a.r(e);var s=a(28),r=Object(s.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"git-flow-工作流"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#git-flow-工作流"}},[t._v("#")]),t._v(" git flow 工作流")]),t._v(" "),s("h2",{attrs:{id:"概述"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[t._v("#")]),t._v(" 概述")]),t._v(" "),s("p",[s("img",{attrs:{src:a(257),alt:"The Feathers chat application"}})]),t._v(" "),s("p",[t._v("GitFlow 工作流定义了一个围绕项目发布的严格分支模型。虽然比功能分支工作流复杂几分，但提供了用于一个健壮的用于管理大型项目的框架。")]),t._v(" "),s("p",[t._v("GitFlow 工作流没有用超出功能分支工作流的概念和命令，而是为不同的分支分配一个很明确的角色，并定义分支之间如何和什么时候进行交互。\n除了使用功能分支，在做准备、维护和记录发布也使用各自的分支。当然你可以用上功能分支工作流所有的好处：Pull Requests、隔离实验性开发和更高效的协作。")]),t._v(" "),s("h2",{attrs:{id:"工作方式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#工作方式"}},[t._v("#")]),t._v(" 工作方式")]),t._v(" "),s("p",[t._v("GitFlow 工作流仍然用中央仓库作为所有开发者的交互中心。和其它的工作流一样，开发者在本地工作并 push 分支到中央仓库中。")]),t._v(" "),s("h2",{attrs:{id:"历史分支"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#历史分支"}},[t._v("#")]),t._v(" 历史分支")]),t._v(" "),s("p",[t._v("相对使用仅有的一个 master 分支，GitFlow 工作流使用2个分支来记录项目的历史。master 分支存储了正式发布的历史，而 develop 分支作为功能的集成分支。\n这样也方便 master 分支上的所有提交分配一个版本号。")]),t._v(" "),s("p",[s("img",{attrs:{src:a(258),alt:"The Feathers chat application"}})]),t._v(" "),s("p",[t._v("剩下要说明的问题围绕着这2个分支的区别展开。")]),t._v(" "),s("h2",{attrs:{id:"功能分支"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#功能分支"}},[t._v("#")]),t._v(" 功能分支")]),t._v(" "),s("p",[t._v("每个新功能位于一个自己的分支，这样可以 push 到中央仓库以备份和协作。但功能分支不是从 master 分支上拉出新分支，而是使用 develop 分支作为父分支。当新功能完成时，\n合并回 develop 分支。新功能提交应该从不直接与 master 分支交互。\n"),s("img",{attrs:{src:a(259),alt:"The Feathers chat application"}}),t._v("\n注意，从各种含义和目的上来看，功能分支加上 develop 分支就是功能分支工作流的用法。但 GitFlow 工作流没有在这里止步。")]),t._v(" "),s("h2",{attrs:{id:"发布分支"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#发布分支"}},[t._v("#")]),t._v(" 发布分支")]),t._v(" "),s("p",[s("img",{attrs:{src:a(260),alt:"The Feathers chat application"}})]),t._v(" "),s("p",[t._v("一旦 develop 分支上有了做一次发布（或者说快到了既定的发布日）的足够功能，就从 develop 分支上 fork 一个发布分支。新建的分支用于开始发布循环，\n所以从这个时间点开始之后新的功能不能再加到这个分支上 —— 这个分支只应该做 Bug 修复、文档生成和其它面向发布任务。一旦对外发布的工作都完成了，发布分支合并到 master\n分支并分配一个版本号打好 Tag。另外，这些从新建发布分支以来的做的修改要合并回 develop 分支。")]),t._v(" "),s("p",[t._v("使用一个用于发布准备的专门分支，使得一个团队可以在完善当前的发布版本的同时，另一个团队可以继续开发下个版本的功能。这也打造定义良好的开发阶段\n（比如，可以很轻松地说，『这周我们要做准备发布版本 4.0』，并且在仓库的目录结构中可以实际看到）。")]),t._v(" "),s("p",[t._v("常用的分支约定：")]),t._v(" "),s("ul",[s("li",[t._v("用于新建发布分支的分支: develop")]),t._v(" "),s("li",[t._v("用于合并的分支: master")]),t._v(" "),s("li",[t._v("分支命名: release-* 或 release/*")])]),t._v(" "),s("h2",{attrs:{id:"维护分支"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#维护分支"}},[t._v("#")]),t._v(" 维护分支")]),t._v(" "),s("p",[s("img",{attrs:{src:a(261),alt:"The Feathers chat application"}})]),t._v(" "),s("p",[t._v("维护分支或说是热修复（hotfix）分支用于生成快速给产品发布版本（production releases）打补丁，这是唯一可以直接从 master 分支 fork 出来的分支。\n修复完成，修改应该马上合并回 master 分支和 develop 分支（当前的发布分支），master 分支应该用新的版本号打好 Tag。")]),t._v(" "),s("p",[t._v("为 Bug 修复使用专门分支，让团队可以处理掉问题而不用打断其它工作或是等待下一个发布循环。你可以把维护分支想成是一个直接在 master 分支上处理的临时发布。")])])}),[],!1,null,null,null);e.default=r.exports}}]);