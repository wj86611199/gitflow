(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{262:function(t,a,s){t.exports=s.p+"assets/img/screen-shot-2014-03-08-at-23-07-361.1110fab2.png"},276:function(t,a,s){"use strict";s.r(a);var e=s(28),r=Object(e.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"github-flow-工作流"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#github-flow-工作流"}},[t._v("#")]),t._v(" github flow 工作流")]),t._v(" "),e("h2",{attrs:{id:"概述"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[t._v("#")]),t._v(" 概述")]),t._v(" "),e("p",[t._v("GitHub Flow 推荐做法是只有一个主分支 master，团队成员们的分支代码通过 pull Request 来合并到 master 上。\n"),e("img",{attrs:{src:s(262),alt:"The Feathers chat application"}})]),t._v(" "),e("h2",{attrs:{id:"github-flow-模型简单说明"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#github-flow-模型简单说明"}},[t._v("#")]),t._v(" GitHub Flow 模型简单说明")]),t._v(" "),e("p",[t._v("第一步：根据需求，从master拉出新分支，不区分功能分支或补丁分支。")]),t._v(" "),e("p",[t._v("第二步：新分支开发完成后，或者需要讨论的时候，就向master发起一个pull request（简称PR）3. 在本地分支提交代码，并且保证按时向远程仓库推送。")]),t._v(" "),e("p",[t._v("第三步：Pull Request既是一个通知，让别人注意到你的请求，又是一种对话机制，大家一起评审和讨论你的代码。对话过程中，你还可以不断提交代码。")]),t._v(" "),e("p",[t._v("第四步：你的Pull Request被接受，合并进master，重新部署后，原来你拉出来的那个分支就被删除。（先部署再合并也可。）")]),t._v(" "),e("h2",{attrs:{id:"特点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#特点"}},[t._v("#")]),t._v(" 特点")]),t._v(" "),e("p",[t._v('Github flow 的最大优点就是简单，对于"持续发布"的产品，可以说是最合适的流程。')]),t._v(" "),e("p",[t._v("问题在于它的假设：master分支的更新与产品的发布是一致的。也就是说，master分支的最新代码，默认就是当前的线上代码。")]),t._v(" "),e("p",[t._v("可是，有些时候并非如此，代码合并进入master分支，并不代表它就能立刻发布。比如，苹果商店的APP提交审核以后，等一段时间才能上架。\n这时，如果还有新的代码提交，master分支就会与刚发布的版本不一致。另一个例子是，有些公司有发布窗口，只有指定时间才能发布，这也会导致线上版本落后于master分支。")])])}),[],!1,null,null,null);a.default=r.exports}}]);