(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{263:function(t,a,s){t.exports=s.p+"assets/img/bg2015122306.c53d25b9.png"},264:function(t,a,s){t.exports=s.p+"assets/img/bg2015122307.289d753b.png"},277:function(t,a,s){"use strict";s.r(a);var e=s(28),r=Object(e.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"gitlab-flow-工作流"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#gitlab-flow-工作流"}},[t._v("#")]),t._v(" gitlab flow 工作流")]),t._v(" "),e("h2",{attrs:{id:"概述"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[t._v("#")]),t._v(" 概述")]),t._v(" "),e("p",[t._v("Gitlab flow 是 Git flow 与 Github flow 的综合。它吸取了两者的优点，既有适应不同开发环境的弹性，又有单一主分支的简单和便利。它是 Gitlab.com 推荐的做法。\nGitLab 既支持 Git Flow 的分支策略，也有 GitHub Flow 的 Pull Request（ Merge Request ） 和 issue tracking。")]),t._v(" "),e("h2",{attrs:{id:"上游优先"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#上游优先"}},[t._v("#")]),t._v(" 上游优先")]),t._v(" "),e("p",[t._v('Gitlab flow 的最大原则叫做"上游优先"（upsteam first），即只存在一个主分支master，它是所有其他分支的"上游"。只有上游分支采纳的代码变化，才能应用到其他分支。')]),t._v(" "),e("h2",{attrs:{id:"持续发布"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#持续发布"}},[t._v("#")]),t._v(" 持续发布")]),t._v(" "),e("p",[e("img",{attrs:{src:s(263),alt:"The Feathers chat application"}}),t._v('\n开发分支是预发分支的"上游"，预发分支又是生产分支的"上游"。代码的变化，必须由"上游"向"下游"发展。比如，生产环境出现了bug，这时就要新建一个功能分支，先把它合并到master，确认没有问题，\n再cherry-pick到pre-production，这一步也没有问题，才进入production。')]),t._v(" "),e("p",[t._v("只有紧急情况，才允许跳过上游，直接合并到下游分支。")]),t._v(" "),e("h2",{attrs:{id:"版本发布"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#版本发布"}},[t._v("#")]),t._v(" 版本发布")]),t._v(" "),e("p",[e("img",{attrs:{src:s(264),alt:"The Feathers chat application"}}),t._v("\n只有当对外发布软件的时候，才需要创建 release 分支。作为一个移动端开发来说，对外发布版本的记录是非常重要的，如果线上出现了一个问题，需要拿到问题出现对应版本的代码，才能准确定位问题。\n在 Git Flow ,版本记录是通过 master 上的 tag 来记录。发现问题，创建 hotfix 分支，完成之后合并到 master 和 develop。")]),t._v(" "),e("p",[t._v("在 GitLab Flow ，建议的做法是每一个稳定版本，都要从master分支拉出一个分支，比如2-3-stable、2-4-stable等等。发现问题，就从对应版本分支创建修复分支，完成之后，先合并到 master，\n才能再合并到 release 分支，遵循 “上游优先” 原则。")])])}),[],!1,null,null,null);a.default=r.exports}}]);